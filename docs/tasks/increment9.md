# Инкремент 9
Реализуйте механизм подписи передаваемых данных по алгоритму SHA256.
Для этого расширьте структуру:
```json
  type Metrics struct {
        ID    string   `json:"id"`              // имя метрики
        MType string   `json:"type"`            // параметр, принимающий значение gauge или counter
        Delta *int64   `json:"delta,omitempty"` // значение метрики в случае передачи counter
        Value *float64 `json:"value,omitempty"` // значение метрики в случае передачи gauge
        Hash  string   `json:"hash,omitempty"`  // значение хеш-функции
  }
```

Хеш нужно считать от строки с учётом ключа, который передан агенту/серверу на старте:

    для counter — hash(fmt.Sprintf("%s:counter:%d", id, delta), key),
    для gauge — hash(fmt.Sprintf("%s:gauge:%f", id, value), key).

## Агент
- добавьте поддержку аргумента через флаг `k=<КЛЮЧ>`;
- добавьте поддержку аргумента через переменную окружения `KEY=<КЛЮЧ>`;
- при наличии ключа агент должен вычислять хеш и передавать в поле hash запроса.

## Сервер
- добавьте поддержку аргумента через флаг `k=<КЛЮЧ>`;
- добавьте поддержку аргумента через переменную окружения `KEY=<КЛЮЧ>`;
- при наличии ключа во время обработки запроса сервер должен проверять соответствие полученного и вычисленного хеша;
- при несовпадении сервер должен отбрасывать полученные данные и возвращать `http.StatusBadRequest`;
- при наличии ключа на этапе формирования ответа сервер должен вычислять хеш и передавать его в соответствующем поле `hash` ответа.
